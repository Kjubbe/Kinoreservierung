package controller;

import java.awt.event.*;

import java.util.ArrayList;
import java.util.List;

import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JRadioButton;
import javax.swing.JTextField;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import model.*;
import view.*;

/**
 * Controller class, acts as an intermediary between view and model defines what
 * should happen on user interaction
 * @author Kjell Treder
 * @author Marcel Sauer
 */

public class KinoController extends KeyAdapter implements ActionListener, ItemListener, ChangeListener {

    // References to view and model
    private KinoView view;
    private KinoModel model;

    /**
     * Constructor, assigns references to view and model
     * @param view reference to the view object
     * @param model reference to the model object
     */
    public KinoController(KinoView view, KinoModel model) {
        this.view = view;
        this.model = model;
    }

    /**
     * invoked when user interacts with a JButton, JRadioButton or JCheckBox
     * @param e the event generated by the component with the listener
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("\n" + "DEBUG: " + "ctrl: click registered..."); // DEBUG
        Object source = e.getSource(); // store the source object
        String cmd = e.getActionCommand(); // get the action command
        if (source instanceof JButton) { // source from JButton > source is either back-, quit-, proceed- or finishbutton
            System.out.println("DEBUG: " + "ctrl: identified as button"); // DEBUG
            if (cmd.equals(Vocabulary.BACK_BUTTON)) // back button
                view.back();
            else if (cmd.equals(Vocabulary.QUIT_BUTTON)) // quit button
                model.quit();
            else if (cmd.equals(Vocabulary.PROCEED_BUTTON)) // proceed button
                view.proceed();
            else if (cmd.equals(Vocabulary.FINISH_BUTTON)) { // finish button
                orderMade();
            }
        } else if (source instanceof JRadioButton) { // source from JRadioButton > source is from time tab
            System.out.println("DEBUG: " + "ctrl: identified as radio-button"); // DEBUG
            int index = Integer.parseInt(cmd); // get the index from the action command
            System.out.println("DEBUG: " + "ctrl: Time chosen"); // DEBUG
            model.setTime(index); // advice the model to set the time to the index specified
            view.update();
        } else if (source instanceof JCheckBox) { // source from JCheckBox > source is from seat tab
            System.out.println("DEBUG: " + "ctrl: identified as checkbox"); // DEBUG
            seatChanged();
        }
    }

    /**
     * invoked when user interacts with a JComboBox > movie selected
     * @param e the event generated by the component with the listener
     */
    @Override
    public void itemStateChanged(ItemEvent e) {
        System.out.println("\n" + "DEBUG: " + "ctrl: click registered..."); // DEBUG
        System.out.println("DEBUG: " + "ctrl: identified as combobox"); // DEBUG
        Movie movie = (Movie) e.getItem(); // get the selected movie from the JComboBox
        System.out.println("DEBUG: " + "ctrl: Movie chosen"); // DEBUG
        if (movie != null) // check if an actual movie is selected
            model.setMovie(movie); // adivice model to set the movie
        view.update();
    }

    /**
     * invoked when user interacts with a JTextField by typing
     * @param e the event generated by the component with the listener
     */
    @Override
    public void keyReleased(KeyEvent e) {
        System.out.println("\n" + "DEBUG: " + "ctrl: key type registered..."); // DEBUG
        System.out.println("DEBUG: " + "ctrl: identified as textfield"); // DEBUG
        licensePlateChanged(); // source is from JTextField > source from seat tab for license plates
    }

    /**
     * invoked when user interacts with a JSpinner
     * @param e the event generated by the component with the listener
     */
    @Override
    public void stateChanged(ChangeEvent e) {
        System.out.println("\n" + "DEBUG: " + "ctrl: click registered..."); // DEBUG
        System.out.println("DEBUG: " + "ctrl: identified as spinner"); // DEBUG
        cateringChanged(); // source is from JSpinner > source from catering tab
    }

    /**
     * invoked from event, searches for chosen seats in view
     * advises model to change chosen seats
     * updates view
     */
    private void seatChanged() { // TODO update this logic
        System.out.println("DEBUG: " + "ctrl: Seat chosen"); // DEBUG
        SeatingTab tab = (SeatingTab) view.tabs[3]; // get reference to the seating tab from the view
        JCheckBox[][] cbs = tab.getCheckBoxes(); // get reference to all JCheckBoxes from the tab
        int rowAmount = cbs.length; // amount of rows of JCheckBoxes
        int columnAmount = cbs[0].length; // amount of columns of JCheckBoxes

        List<Seat> seats = new ArrayList<>(); // create a new list, which will contain every selected seat
        for (int row = 0; row < rowAmount; row++) { // every row
            for (int column = 0; column < columnAmount; column++) { // checks every column of every row
                JCheckBox currentCB = cbs[row][column]; // get the JCheckBox at the current row and column position
                if (currentCB.isSelected()) { // JCheckBox is selected
                    Seat equivalentSeat = model.availableSeats[row][column]; // get the seat at position row|column from the model, which is equivalent to the position of the JCheckBox
                    seats.add(equivalentSeat); // add the seat to the list
                }
            }
        }
        model.setSeats(seats); // advice model to set the new seats
        view.update();
    }

    /**
     * invoked from event, gets input from JTextFields
     * advises model to change license plates
     * updates view
     */
    private void licensePlateChanged() {
        System.out.println("DEBUG: " + "ctrl: license plate changed"); // DEBUG
        SeatingTab tab = (SeatingTab) view.tabs[3]; // get reference to the seating tab from the view
        List<JTextField> tfs = tab.getTextFields(); // get JTextFields from the tab
        List<String> lps = new ArrayList<>(); // create a new list to store the license plate strings
        for (JTextField tf : tfs) { // check every JTextField
            lps.add(tf.getText().replaceAll("\\s+", "")); // add the text from the JTextField to the list
        }
        model.setLicensePlates(lps); // advice model to set the new license plates
        view.update();
    }

    /**
     * invoked from event, gets setting from all SpinnerNumberModels
     * advises model to change chosen caterings
     * updates view
     */
    private void cateringChanged() { // TODO update this logic
        System.out.println("DEBUG: " + "ctrl: Catering chosen"); // DEBUG
        CateringTab tab = (CateringTab) view.tabs[4]; // get reference to the catering tab from the view
        List<SpinnerModel> spinnerModels = tab.getSpinnerModels(); // get reference to all SpinnerNumberModels from the view
        List<Integer> cateringCounts = new ArrayList<>();
        for (SpinnerModel snm : spinnerModels) {
            cateringCounts.add((Integer)snm.getValue());
        }
        model.setCatering(cateringCounts); // model receives map with catering-amount pairs
        view.update();
    }

    /**
     * invoked from event, when finishing the order
     * advises model to order and reset
     * updates and advises view to finish
     */
    private void orderMade() {
        System.out.println("DEBUG: " + "ctrl: ordering..."); // DEBUG
        model.order(); // advice the model to order
        view.finish(); // advice the view to finish
        model.reset(4); // adivce the model to reset everything
        view.update();
    }
}